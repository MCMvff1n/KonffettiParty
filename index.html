function clearSelection(pop=false) {
  if(pop && selected.length > 0) {
    // Speichere Indizes der entfernten Kacheln
    const removedIndices = selected.map(t => +t.dataset.i);

    // Animationsstart für pop
    selected.forEach((t, i) => {
      t.style.transition = 'transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.4s ease';
      t.style.transform = 'scale(1.4)';
      setTimeout(() => {
        t.style.transform = 'scale(0.2)';
        t.style.opacity = '0';
      }, 250);
    });

    // Konfetti von entfernten Kacheln
    const points = selected.map(t => {
      const c = center(t);
      return { x: c.x, y: c.y };
    });
    emitConfetti(points);

    setTimeout(() => {
      // Entferne die Kacheln aus DOM + tiles Array
      removedIndices.sort((a,b) => b - a).forEach(idx => {
        const tile = tiles[idx];
        if(tile && tile.parentNode) tile.parentNode.removeChild(tile);
        tiles.splice(idx, 1);
      });

      // Jetzt nachrutschen & auffüllen
      collapseColumns(removedIndices);

      selected = [];
      ctx.clearRect(0,0,lineCanvas.width,lineCanvas.height);
    }, 650);
  } else {
    // Keine pop Animation, nur Auswahl zurücksetzen
    selected.forEach(t=>{
      t.classList.remove("selected");
      t.style.transition = '';
      t.style.transform = '';
      t.style.opacity = '';
    });
    selected = [];
    ctx.clearRect(0,0,lineCanvas.width,lineCanvas.height);
  }
}

/**
 * Lässt die Tiles in den betroffenen Spalten nachrutschen und füllt oben neu auf
 */
function collapseColumns(removedIndices) {
  // Ermittle betroffene Spalten
  const cols = new Set(removedIndices.map(i => i % 8));

  cols.forEach(col => {
    // Für jede Spalte: erstelle Array mit Tiles in dieser Spalte sortiert von unten nach oben (y 7 bis 0)
    let colTiles = [];
    for(let row = 7; row >= 0; row--) {
      let idx = row * 8 + col;
      if(tiles[idx]) colTiles.push(tiles[idx]);
      else colTiles.push(null);
    }

    // Wie viele Tiles wurden entfernt in dieser Spalte?
    const removedInCol = removedIndices.filter(i => i % 8 === col);

    // Entferne alle nulls und sortiere spalte nach existierenden Tiles (unten beginnend)
    colTiles = colTiles.filter(t => t !== null);

    // Anzahl der neuen Tiles, die wir oben auffüllen müssen
    const fillCount = 8 - colTiles.length;

    // Neue Tiles oben erzeugen
    let newTiles = [];
    for(let i = 0; i < fillCount; i++) {
      const t = document.createElement("div");
      t.className = "tile";
      const c = colors[Math.floor(Math.random()*colors.length)];
      t.style.background = c;
      t.dataset.color = c;
      board.appendChild(t);
      newTiles.push(t);
    }

    // Erneuere tiles array für die Spalte
    // Rebuild colTiles: zuerst newTiles oben, dann bestehende unten
    const newColTiles = [...newTiles, ...colTiles];

    // Update tiles array: newColTiles von oben (row 0) bis unten (row 7)
    for(let row = 0; row < 8; row++) {
      let newIndex = row * 8 + col;
      let tile = newColTiles[7 - row]; // weil colTiles war von unten nach oben
      if(tile) {
        tiles[newIndex] = tile;
        tile.dataset.i = newIndex;
        tile.classList.remove("selected","pop");
        tile.style.transition = '';
        tile.style.transform = '';
        tile.style.opacity = '';
        tile.style.background = tile.dataset.color; // sicherheitshalber
      }
    }
  });

  // Animation für das Nachrutschen:
  animateCollapse(cols);
}

/**
 * Animation: Die Tiles rutschen optisch runter
 */
function animateCollapse(cols) {
  // Für jede Spalte: finde Tiles, die "fallen" müssen
  cols.forEach(col => {
    // Array der Y Positionen die fehlen (also Löcher)
    let holes = [];
    for(let row = 7; row >= 0; row--) {
      let idx = row * 8 + col;
      if(!tiles[idx]) holes.push(row);
    }

    if(holes.length === 0) return;

    // Für jedes Loch: alle Tiles über dem Loch um 1 nach unten animieren
    holes.forEach(holeRow => {
      for(let r = holeRow - 1; r >= 0; r--) {
        let idx = r * 8 + col;
        let tile = tiles[idx];
        if(tile) {
          // Animieren: verschieben um (holeRow - r) * tileHeight runter
          tile.style.transition = 'transform 0.3s ease';
          tile.style.transform = `translateY(${(holeRow - r) * (parseInt(getComputedStyle(tile).width))}px)`;
        }
      }
    });
  });

  // Nach Animation alle Transform zurücksetzen, damit Position wieder stimmt
  setTimeout(() => {
    for(let i=0; i < tiles.length; i++) {
      let t = tiles[i];
      if(t) {
        t.style.transition = '';
        t.style.transform = '';
      }
    }
  }, 350);
}
